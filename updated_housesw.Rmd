---
title: "updated_housesw.Rmd"
author: "lizzie tucker and Prof. Wendy Tam"
last updated: "2025-12-30"
output: html_document
---

```{r setup, include=TRUE}
# Change working directory to wherever your clone is
setwd("C:/Users/lizzi/congress/data")
# Load required packages
library(sna)
library(igraph)
```

```{r}
## read in the data

# core vectors
sponsors   <- scan("sponsors.vec", what = integer(), quiet = TRUE)
years      <- scan("years.vec", what = integer(), quiet = TRUE)
numchamber <- scan("chamber.vec", what = integer(), quiet = TRUE)

# cosponsor vector
cosponsors_raw <- readLines("cosponsors.vec")
cosponsors_raw <- cosponsors_raw[-1]               # drop first blank line
cosponsors_raw[cosponsors_raw == "NA"] <- ""       # normalize NA -> empty

if (length(cosponsors_raw) > length(sponsors)) {
  cosponsors_raw <- cosponsors_raw[1:length(sponsors)]
}
cosponsors <- cosponsors_raw

sponsor_party   <- readLines("sponsor_party.vec")
cosponsors_party <- readLines("cosponsors_party.vec")

# cheatsheet for ICPSR -> name
icpsr_house <- read.csv("ICPSR_house_cheatsheet.csv", stringsAsFactors = FALSE)

# standardizing cheatsheet columns
names(icpsr_house) <- tolower(names(icpsr_house))
icpsr_house$icpsr <- as.integer(icpsr_house$icpsr)
icpsr_house$name  <- trimws(icpsr_house$name)

icpsr_to_name <- setNames(icpsr_house$name, as.character(icpsr_house$icpsr))

# length checks (everything that should align with bills)
lens <- c(
  sponsors = length(sponsors),
  years = length(years),
  numchamber = length(numchamber),
  cosponsors = length(cosponsors),
  sponsor_party = length(sponsor_party),
  cosponsors_party = length(cosponsors_party)
)
print(lens)

if (!(lens["sponsors"] == lens["years"] &&
      lens["years"] == lens["numchamber"] &&
      lens["numchamber"] == lens["cosponsors"] &&
      lens["cosponsors"] == lens["sponsor_party"] &&
      lens["sponsor_party"] == lens["cosponsors_party"])) {
  stop("ERROR: One or more vectors are not the same length. See printed lengths above.")
}
```

```{r}
## Used this to build the bill_congress.vec, but still run this even if you have that because it sets up important variables for graphing and bipartisanship calculations.
## Builds global mapping: bill index to congress number (108–118)
## Uses per-Congress sponsors_by_icpsr_id_XXX.csv as ground truth for bill ordering/counts
congresses <- 108:118

# count bills in each congress from per-congress subfolders
bill_counts <- vapply(congresses, function(cg) {
  path <- file.path(as.character(cg), paste0("sponsors_by_icpsr_id_", cg, ".csv"))
  if (!file.exists(path)) stop("Missing file: ", path)
  nrow(read.csv(path, stringsAsFactors = FALSE))
}, integer(1))

bill_counts
sum(bill_counts)

# compute start/end global indices for each congress
start_idx <- cumsum(c(1, head(bill_counts, -1)))
end_idx   <- cumsum(bill_counts)

congress_ranges <- data.frame(
  congress = congresses,
  start = start_idx,
  end = end_idx,
  n_bills = bill_counts
)

print(congress_ranges)

# build bill to congress mapping for ALL bills in vectors
bill_congress <- rep(NA_integer_, length(sponsors))
for (k in seq_along(congresses)) {
  bill_congress[start_idx[k]:end_idx[k]] <- congresses[k]
}

stopifnot(length(bill_congress) == length(sponsors))
stopifnot(all(!is.na(bill_congress)))

# convenience: function to get indices for a given congress (global indices)
indices_for_congress <- function(cg) {
  which(bill_congress == cg)
}

# example use for later:
# idx_118 <- indices_for_congress(118)
# idx_house_118 <- idx_118[numchamber[idx_118] == 2]
```

```{r}
## Save bill_congress.vec IF NOT already saved. Makes the data more scalable. 
## Don't have to do this if it is already saved.
writeLines(as.character(bill_congress), "bill_congress.vec")
```

```{r}
## AFTER THIS ONLY HOUSE BILLS EXIST IN THIS FILE
# separate bills into house and senate (H=2, S=1 in numchamber)
# house is length 98414

house_idx <- which(numchamber == 2)
hs            <- sponsors[house_idx]
hcs           <- cosponsors[house_idx]
hyears        <- years[house_idx]
hs_party      <- sponsor_party[house_idx]
hcs_party     <- cosponsors_party[house_idx]
hcongress <- bill_congress[house_idx]
```

```{r}
## Bipartisan cosponsorship score (bill-level, averaged within each Congress)
## takes about 15 seconds to run

# splits a party line into tokens
split_party_tokens <- function(line) {
  if (is.na(line)) return(character(0))
  line <- trimws(line)
  if (line == "" || toupper(line) == "NA") return(character(0))
  toks <- unlist(strsplit(line, "\\s+"))
  toks <- toks[toks != ""]
  toupper(toks)
}

# normalize sponsor party (single token)
norm_party <- function(p) {
  if (is.na(p)) return(NA_character_)
  p <- toupper(trimws(p))
  if (p == "" || p == "NA") return(NA_character_)
  p
}

# compute bill-level bipartisanship score:
# score_i = (# cosponsors with party != sponsor party) / (# cosponsors with known party)
bill_score <- rep(NA_real_, length(hs))

for (i in seq_along(hs)) {
  sp <- norm_party(hs_party[i])
  if (is.na(sp)) next

  cp <- split_party_tokens(hcs_party[i])
  if (length(cp) == 0) next

  # keep only known party tokens (D/R/I)
  cp <- cp[cp %in% c("D", "R", "I")]
  if (length(cp) == 0) next

  bill_score[i] <- mean(cp != sp)
}

# summarize by congress
congresses_here <- sort(unique(hcongress))

bipartisan_by_congress <- data.frame(
  congress = congresses_here,
  n_bills = as.integer(table(hcongress)[as.character(congresses_here)]),
  n_scored_bills = NA_integer_,
  mean_bill_bipartisan_share = NA_real_,
  median_bill_bipartisan_share = NA_real_
)

for (k in seq_along(congresses_here)) {
  cg <- congresses_here[k]
  idx <- which(hcongress == cg)

  scores <- bill_score[idx]
  scores <- scores[!is.na(scores)]

  bipartisan_by_congress$n_scored_bills[k] <- length(scores)
  bipartisan_by_congress$mean_bill_bipartisan_share[k] <- if (length(scores) == 0) NA_real_ else mean(scores)
  bipartisan_by_congress$median_bill_bipartisan_share[k] <- if (length(scores) == 0) NA_real_ else median(scores)
}

bipartisan_by_congress
```

```{r}
## create cosponsorship ties
## output is
##    sponsor cosponsor
## adapted the older edges function to be a bit faster
edges <- function(spons, cospons) {
  out <- list()
  k <- 1
  for (i in seq_along(spons)) {
    # cosponsors for bill i
    line <- cospons[i]
    if (is.na(line) || line == "") next
    ids <- unlist(strsplit(line, " "))
    ids <- ids[ids != ""]
    ids <- as.numeric(ids)
    ids <- ids[!is.na(ids)]
    # create edges
    for (c in ids) {
      out[[k]] <- c(spons[i], c)
      k <- k + 1
    }
  }
  do.call(rbind, out)
}

```

```{r}
## next adapting the adj matrix, but need to create the updated ICPSR id list
## first--can do this by running code in new database--will make a scalable
## script
1 + 1
```

```{r}
## Calculates House Productivity Percentages for Each Congress 108-118
library(readxl)
library(stringr)

# Constants pulled from data folders
congresses <- 108:118

total_HRs <- c(
  `108` = 5431,
  `109` = 6436,
  `110` = 7340,
  `111` = 6570,
  `112` = 6729,
  `113` = 5893,
  `114` = 6536,
  `115` = 7401,
  `116` = 9067,
  `117` = 9709,
  `118` = 10564
)

# helper: Counts non-empty entries in each congress column 
count_entries_by_congress <- function(path, congresses = 108:118) {
  df <- read_excel(path)

  vapply(congresses, function(cg) {
    col <- as.character(cg)
    if (!col %in% names(df)) return(0L)

    x <- as.character(df[[col]])
    sum(!is.na(x) & str_trim(x) != "")
  }, integer(1))
}

# Pulls counts from House spreadsheets
total_commemorative <- count_entries_by_congress(
  "significance_encodings/CListHouse.xlsx",
  congresses
)

total_subsig <- count_entries_by_congress(
  "significance_encodings/SSListHouse.xlsx",
  congresses
)

# Calculates percentages and substantive total
total_substantive <- total_HRs - (total_subsig + total_commemorative)

percentage_com         <- total_commemorative / total_HRs
percentage_subsig      <- total_subsig / total_HRs
percentage_substantive <- total_substantive / total_HRs

# Example single variable use
# total_commemorative["108"]
# total_subsig["115"]
# percentage_substantive["118"]
```

```{r}
## Graph creation for productivity over time
library(ggplot2)
library(tidyr)
library(scales)

# Build plotting dataframe from existing variables
plot_df <- data.frame(
  congress = congresses,
  commemorative = percentage_com,
  subsignificant = percentage_subsig,
  substantive = percentage_substantive
)

# Reshape for ggplot
plot_long <- pivot_longer(
  plot_df,
  cols = -congress,
  names_to = "category",
  values_to = "percentage"
)

# Labels
plot_long$category <- factor(
  plot_long$category,
  levels = c("substantive", "subsignificant", "commemorative"),
  labels = c("Substantive", "Substantive and Significant", "Commemorative")
)

# Plot
ggplot(plot_long, aes(x = congress, y = percentage, color = category)) +
  geom_line(linewidth = 1.2) +
  geom_point(size = 2) +
  scale_x_continuous(breaks = congresses) +
  scale_y_continuous(labels = percent_format()) +
  labs(
    title = "House Productivity by Congress (108–118)",
    x = "Congress",
    y = "Share of Bills",
    color = "Bill Type"
  ) +
  theme_minimal(base_size = 13)

```
